#!/usr/bin/perl -w
# vim:tabstop=4:shiftwidth=4
# =======================================================================
# Company:              Server Beach
# Copyright(c):         Server Beach 2006
# Project:              Kickstart Sub-System
# Code Devloper:        SB Development Team
# Creation Date:        2006-09-14
#
# File Type:            Taskfile
# File Name:            burnin.txt
#
# Discription:
# This script is the primary script that is called directly from the pxe image
# for all Red Hat based kicks (RHBK). It servers as the launch point from which
# a RHBK locates pre, during, and post configuration information.
#
# =======================================================================

# File inlcudes.
BEGIN {
	use lib '/exports/kickstart/lib';
	require 'sbks.pm';
}

use strict;
use LWP::Simple;
use LWP::UserAgent;
use XML::Simple;
use CGI ':cgi-lib';
use CGI ':standard';

# Variable Defitions
my ( $dbh, $ipaddr, $macaddr, $macobj, $status, $osload );

# ############################################
# FUNCTION DEFFITIONS
# ############################################
sub get_kscfg {
	my $ks      = shift();
	my $testing = shift();

	#############################################################
	# Base kickstart configuration filename
	#############################################################
	my $kscfg = $Config->{ks_home} . "/kscfg/$ks.kscfg";

	#############################################################
	# Read default kickstart configuration file
	#############################################################
	my @kscfg;
	if ( -e $kscfg ) {
		open IFH, "<$kscfg";
		while (<IFH>) {
			chomp;
			if (/(\@\@KSSERVER\@\@)/) { $_ =~ s/$1/$Config->{'ks_host'}/g; }
			if (/(\@\@KSIPADDR\@\@)/) { $_ =~ s/$1/$Config->{'ks_ipaddr'}/g; }
			if (/(\@\@KSDOMAIN\@\@)/) { $_ =~ s/$1/$Config->{'ks_domain'}/g; }
			push( @kscfg, $_ );
		}
		close IFH;
	}
	else {
		kslog( "err", "[$macaddr] Kickstart config couldn't be found." );
		return 1;
	}

	#############################################################
	#  Load partition information from partition_master.cgi
	#############################################################
	kslog("info", "[$macaddr] Getting partition recipe from partition_master.cgi.");
	my $ua = LWP::UserAgent->new;
	my $response = $ua->get("http://localhost/cgi-bin/partition_master.cgi?macaddr=$macaddr");
	my $partition_recipe = "";
	if( $response->is_success ) {
		$partition_recipe = $response->decoded_content;
	}
	kslog("info", "[$macaddr] Found parition recipe:\n $partition_recipe");

	#############################################################
	# Pre-config filename, default or per-os
	#############################################################
	my $ksPre;
	if ( -e $Config->{ks_home} . "/kscfg/$ks.pre" ) {
		$ksPre = $Config->{ks_home} . "/kscfg/$ks.pre";
	}
	else {
		$ksPre = $Config->{ks_home} . "/kscfg/rhcommon.pre";
	}

	#############################################################
	# Found preconfig file and no custom parition => use default
	#############################################################
	if ( -e $ksPre ) {
		kslog( "info", "[$macaddr] Using $ksPre." );
		push( @kscfg, '%pre --interpreter /bin/sh' );
		if ($testing) { 
			push( @kscfg, "export testing=1" ); 
		}
		open IFH, "<$ksPre";
		while (<IFH>) {
			chomp;
			if (/(\@\@KSIPADDR\@\@)/) { $_ =~ s/$1/$Config->{'ks_ipaddr'}/g; }
			# Parse out and apply base partition information
			if (/(\@\@PARTITIONRECIPE\@\@)/) { $_ =~ s/$1/$partition_recipe/g; }
			push( @kscfg, $_ );
		}
		close IFH;
		push(@kscfg,'%end');
	}

	#############################################################
	# Post-config file
	#############################################################
	my $ksPost;
	if ( -e $Config->{ks_home} . "/kscfg/$ks.post" ) {
		$ksPost = $Config->{ks_home} . "/kscfg/$ks.post";
	}
	else {
		$ksPost = $Config->{ks_home} . "/kscfg/rhcommon.post";
	}

	if ( -e $ksPost ) {
		push( @kscfg, '%post --interpreter /bin/sh' );
		if ($testing) { push( @kscfg, "export testing=1" ); }
		open IFH, "<$ksPost";
		while (<IFH>) {
			chomp;
			if (/(\@\@KSSERVER\@\@)/) { $_ =~ s/$1/$Config->{'ks_host'}/g; }
			if (/(\@\@KSIPADDR\@\@)/) { $_ =~ s/$1/$Config->{'ks_ipaddr'}/g; }
			if (/(\@\@KSDOMAIN\@\@)/) { $_ =~ s/$1/$Config->{'ks_domain'}/g; }
			push( @kscfg, $_ );
		}
		close IFH;
		push(@kscfg,'%end');
	}

	#############################################################
	# Copy config data to output & local file
	#############################################################
	open LOG, ">/tmp/kscfg-$macaddr.log";
	print "# Generated by ks.cgi\n";
	print LOG "# Generated by ks.cgi\n";
	foreach my $line (@kscfg) {
		print "$line\n";
		print LOG "$line\n";
	}
	close LOG;
	return 0;
}

#$ipaddr = $ENV{'REMOTE_ADDR'};
#if (!defined($ipaddr)) {
#	kslog('err', "I need to be called as a CGI");
#	exit 1;
#}

# ############################################
# Program MAIN
# ############################################

print header;
#Instantiate new CGI Object
my $post     = new CGI;
my $postdata = $post->Vars();

$ipaddr = $ENV{'REMOTE_ADDR'};
if ( !defined($ipaddr) ) {
	kslog( 'err', "I need to be called as a CGI" );
	exit 1;
}

$dbh = ks_dbConnect();

###############################################################################
#
#   # Read in variables that were posted to this cgi.
#   # Red Hat was nice enough to add this HTTP environment variable to the HTTP
#   # headers issued by anaconda.  Saves us a database call if present.
#   if (my $tmpvar = $post->http("HTTP_X_RHN_PROVISIONING_MAC_0")) {
#	    $tmpvar =~ s/^.*\s+//g;
#	    $macaddr = untaint('macaddr', $tmpvar);
#	    kslog("info", "Got MAC ($macaddr) from \$post->http()");
#   }
#   elsif ($post->param("macaddr")) {
#       $macaddr = untaint('macaddr', $post->param("macaddr"));
#	    kslog("info", "Got MAC ($macaddr) from \$post->param()");
#   }
#   else {
#	    $macaddr = get_mac_by_ip($dbh, $ipaddr);
#	    kslog("info", "Got MAC ($macaddr) from database");
#   }
#
###############################################################################

if ( $post->param("macaddr") ) {
	$macaddr = untaint( 'macaddr', $post->param("macaddr") );
	kslog( "info", "Got MAC ($macaddr) from \$post->param()" );
}
else {
	$macaddr = get_mac_from_log($ipaddr);
	if ( !defined($macaddr) ) {
		kslog( 'err', "Unable to find a MAC for $ipaddr" );
		exit 0;
	}
	else {
		kslog( "info", "Got MAC ($macaddr) via IP ($ipaddr) from log" );
	}
}

# Instantiate new MACFun Object.
$macobj = MACFun->new( dbh => $dbh, macaddr => $macaddr );
$status = $macobj->status();
$osload = $macobj->osload();

my $testing  = "";
my $postconf = $macobj->postconf();

if( ! defined( $postconf->{customer_number} ) ) {
        kslog( 'err', "[$macaddr] No postconf information found for IP $ipaddr" );
} elsif ( $postconf->{customer_number} == 7000307 ) {
        # Check to see if the customer is a development
        # testing account.
        $testing = "1";
}

# Get a list of Kickstart PXE Kicks
my @installs = get_ks_list($dbh);
# Search through the oslad variable to see if it matches one
# in the kickstart configuration list.
if ( grep( /^$osload$/, @installs ) ) {
	if ( $osload =~ /up$/ || $status !~ /kickstarted|online/ ) {
		my $result = get_kscfg( $osload, $testing );
		if ( $result == 0 ) {
			$macobj->status("ksscript");
			$macobj->update();
			kslog( 'info', "$macaddr STATUS -> ksscript ($osload)" );
		}
		else {
			$macobj->status("ksscript_fail");
			$macobj->update();
			kslog( 'err', "$macaddr FAILED -> ksscript ($osload)" );
		}
	}
	else {
		$macobj->pxe("localboot");
		$macobj->update();
		update_pxe( $macaddr, "localboot" );
		kslog( 'err', "$macaddr WARNING ATTEMPTED REKICKSTART" );
	}
}
else {
	get_kscfg( $osload, $testing );
	kslog( 'info', "$macaddr got $osload" );
}

1;


